"""Tests for Storage Pathing (Step 7)."""
import pytest
from unittest.mock import MagicMock
from engines.storage.gcs_client import GcsClient

@pytest.fixture
def mock_client():
    mock_gcs = MagicMock()
    # Mock runtime_config
    with pytest.MonkeyPatch.context() as m:
        m.setattr("engines.config.runtime_config.config_snapshot", lambda: {
            "raw_bucket": "raw-bucket",
            "datasets_bucket": "ds-bucket",
            "tenant_id": "system"
        })
        client = GcsClient(client=mock_gcs)
        yield client

def test_upload_raw_media_path(mock_client):
    # Mock the internal _write or just check the call args if we mock the bucket
    # Actually _write calls self._client.bucket().blob(). It's easier to mock _write if we subclass or spy.
    # But let's look at the method logic we changed.
    
    # We can inspect the key generated by calling the method but verifying the 'blob' call on bucket.
    mock_bucket = MagicMock()
    mock_client._client.bucket.return_value = mock_bucket
    mock_blob = MagicMock()
    mock_bucket.blob.return_value = mock_blob
    
    mock_client.upload_raw_media("t_test", "foo.png", b"data", env="prod")
    
    # Verify strict path: tenants/{tenant_id}/{env}/media/{path}
    mock_bucket.blob.assert_called_with("tenants/t_test/prod/media/foo.png")

def test_upload_dataset_path(mock_client):
    mock_bucket = MagicMock()
    mock_client._client.bucket.return_value = mock_bucket
    
    mock_client.upload_dataset("t_test", "data.csv", b"data", env="staging")
    
    # Verify strict path
    mock_bucket.blob.assert_called_with("tenants/t_test/staging/datasets/data.csv")
